Theory
======

Sorting algorithms:
-------------------

# Bubble sort
while there are any changes, for i from 0 to len(arr)-1 compare i and i+1 elem and if arr[i] > arr[i+1] - switch elements
n**2 in worst case 
# Insertion sort
Beginning is sorted. for every next element, if it is < previous, find the right place for it in sorted beginnig, than place it there and shift right part of array
n**2 in worst case
# Selection sort
The beginning of list is sorted. For unsorted part, find min element and switch it with the first unsorted element, then start from the next element 
n**2 in worst case
# Divide and conquer
Reqursively divide element for 2 equal parts, and then merge these parts to one sorted array
n * log(2) n  in worst case, but requires extra memory
# Quicksort
n**2 in the worst case, n log(2)n in average case, no extra memory required, depends on pivot point choose algorythm

Design patterns:
----------------
TODO

Data structures
---------------
TODO

Binary tree
-----------
TODO

Linked list
-----------
TODO

Object oriented analysis
------------------------
TODO

Object oriented design
----------------------
TODO

Practice
========
TODO
